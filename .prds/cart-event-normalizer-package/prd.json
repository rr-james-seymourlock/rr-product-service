{
  "introduction": {
    "title": "Cart Event Normalizer Package",
    "overview": "A TypeScript package (@rr/cart-event-normalizer) that processes raw cart event data from Rakuten apps and browser extensions, normalizes the structure, extracts product identifiers using @rr/product-id-extractor, and outputs a clean array of enriched product objects ready for analytics and downstream services.",
    "lastUpdated": "2025-12-08"
  },
  "problemStatement": {
    "problem": "Our apps and browser extensions capture shopping cart data from users across thousands of merchant sites and stream this data to Snowflake. The raw event JSON contains inconsistent field names, nested structures, and URLs that need product ID extraction. Each downstream consumer (analytics, matching, recommendations) would need to implement their own parsing and enrichment logic, leading to duplicated effort, inconsistent results, and maintenance burden. We need a single package that transforms raw cart events into a clean, consistent product array with extracted identifiers.",
    "marketOpportunity": "Cart data flows through our entire analytics pipeline - from real-time dashboards to ML models for product recommendations. A standardized normalizer ensures consistent data quality across all consumers. With millions of cart events daily, even small improvements in extraction accuracy compound into significant data quality gains. This package also enables future enhancements like price tracking, inventory monitoring, and cross-merchant product matching.",
    "targetUsers": [
      "Data engineers building Snowflake pipelines that consume cart events",
      "Analytics teams needing clean product data for dashboards and reports",
      "ML engineers training models on shopping behavior data",
      "Backend services performing real-time cart analysis"
    ]
  },
  "solutionOverview": {
    "description": "A lightweight package that accepts raw cart event JSON and outputs an array of normalized CartProduct objects. The normalizer: (1) extracts the product_list array from the event, (2) maps each product to a clean schema with consistent field names, (3) uses @rr/product-id-extractor to extract product IDs from URLs, (4) includes store context (store_id) from the parent event, (5) filters out products missing required fields, and (6) returns a frozen array of CartProduct objects. The package handles edge cases like missing fields, malformed URLs, and empty carts gracefully.",
    "keyFeatures": [
      "normalizeCartEvent(event: RawCartEvent): CartProduct[] - Main entry point",
      "Extracts product_list and maps to clean CartProduct schema",
      "Integrates @rr/product-id-extractor to extract product IDs from product URLs",
      "Consistent field naming: title, url, imageUrl, storeId, price, productIds",
      "Filters products missing required fields (url or title)",
      "Includes store_id from parent event on each product for context",
      "Zod schemas for input validation and output typing",
      "Handles edge cases: empty carts, missing fields, malformed URLs",
      "Frozen immutable output arrays for safety",
      "Zero external dependencies beyond @rr/product-id-extractor"
    ],
    "successMetrics": [
      "100% of valid cart events produce normalized output without errors",
      "95%+ product ID extraction rate for products with valid URLs",
      "Sub-1ms normalization time per cart event",
      "Zero data loss - all available product fields preserved",
      "100% test coverage for normalizer logic",
      "Clean integration with existing Snowflake pipeline"
    ]
  },
  "userStories": [
    {
      "id": "US001",
      "title": "Normalize Raw Cart Event",
      "userStory": "As a data engineer, I want to normalize raw cart event JSON into a clean product array so that I can ingest consistent, well-structured product data into Snowflake without writing custom parsing logic",
      "businessValue": "I can ingest consistent, well-structured product data into Snowflake without writing custom parsing logic",
      "acceptanceCriteria": [
        "normalizeCartEvent(event) accepts RawCartEvent and returns CartProduct[]",
        "Output array contains only products with valid url or title",
        "Each CartProduct has: title, url, imageUrl, storeId, price, productIds fields",
        "Empty product_list returns empty array (not error)",
        "Invalid/malformed events throw descriptive errors"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-08"
    },
    {
      "id": "US002",
      "title": "Have Product Ids Automatically",
      "userStory": "As a data engineer, I want to have product IDs automatically extracted from product URLs so that I get enriched product data with identifiers ready for catalog matching without additional processing",
      "businessValue": "I get enriched product data with identifiers ready for catalog matching without additional processing",
      "acceptanceCriteria": [
        "Each product's url is passed to @rr/product-id-extractor",
        "Extracted productIds array added to each CartProduct",
        "Products with no extractable IDs have empty productIds array",
        "Store ID from parent event used for store-specific pattern matching",
        "Extraction failures don't break normalization (graceful degradation)"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-08"
    },
    {
      "id": "US003",
      "title": "Have The Store_id From",
      "userStory": "As a data engineer, I want to have the store_id from the cart event included on each product so that I can filter and group products by store without joining back to the parent event",
      "businessValue": "I can filter and group products by store without joining back to the parent event",
      "acceptanceCriteria": [
        "storeId field populated from parent event's store_id",
        "storeId is required on CartProduct output",
        "Works with numeric store_id values",
        "Handles missing store_id gracefully (use undefined or default)"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-08"
    },
    {
      "id": "US004",
      "title": "Have Consistent Field Naming",
      "userStory": "As a analytics engineer, I want to have consistent field naming across all normalized products so that I can build dashboards and queries without handling field name variations",
      "businessValue": "I can build dashboards and queries without handling field name variations",
      "acceptanceCriteria": [
        "name -> title (consistent naming)",
        "url -> url (unchanged)",
        "image_url -> imageUrl (camelCase)",
        "item_price -> price (simplified)",
        "store_id -> storeId (camelCase)",
        "All output fields use camelCase convention"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "L",
      "dependencies": [],
      "completedAt": "2025-12-08"
    },
    {
      "id": "US005",
      "title": "Validate Input Events Against",
      "userStory": "As a data engineer, I want to validate input events against a Zod schema so that I get clear error messages when upstream data format changes unexpectedly",
      "businessValue": "I get clear error messages when upstream data format changes unexpectedly",
      "acceptanceCriteria": [
        "RawCartEventSchema validates incoming event structure",
        "CartProductSchema defines output structure",
        "Validation errors include field path and expected type",
        "Optional: dev-mode validation, prod skips for performance",
        "Schemas exported for consumers to use"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-08"
    },
    {
      "id": "US006",
      "title": "Have Normalized Output Be",
      "userStory": "As a backend developer, I want to have normalized output be immutable so that I can safely cache and share results without defensive copying",
      "businessValue": "I can safely cache and share results without defensive copying",
      "acceptanceCriteria": [
        "Output CartProduct[] array is Object.freeze()'d",
        "Individual CartProduct objects are frozen",
        "Nested arrays (productIds) are frozen",
        "TypeScript types use readonly modifiers"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-08"
    },
    {
      "id": "US007",
      "title": "Handle Products Without Urls",
      "userStory": "As a data engineer, I want to handle products without URLs gracefully so that I don't lose product data when URLs are missing, and I can still track cart activity",
      "businessValue": "I don't lose product data when URLs are missing, and I can still track cart activity",
      "acceptanceCriteria": [
        "Products without url field are still included in output",
        "productIds is empty array when no URL available",
        "Products with only name/title are valid",
        "Products with only price are valid (minimal product)",
        "Empty product objects are filtered out"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-08",
      "notes": "Updated validation rules: products must have URL, OR if no URL then must have both title AND price"
    },
    {
      "id": "US008",
      "title": "Handle Store_id As Both",
      "userStory": "As a data engineer, I want to handle store_id as both string and number types so that I can process events from both App (string IDs) and Toolbar (numeric IDs) sources without type errors",
      "businessValue": "I can process events from both App (string IDs) and Toolbar (numeric IDs) sources without type errors",
      "acceptanceCriteria": [
        "Numeric store_id (e.g., 8333) parsed correctly",
        "String store_id (e.g., '8333') parsed correctly",
        "Output storeId is always number type",
        "Invalid store_id values handled gracefully"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-09",
      "notes": "SUPERSEDED by US011 - Original spec output storeId as number, but this was changed to string to support non-numeric store IDs like 'uk-87262'"
    },
    {
      "id": "US009",
      "title": "Include Quantity And Line_total",
      "userStory": "As a data engineer, I want to include quantity and line_total in the normalized output so that I can calculate accurate cart analytics including total items and revenue",
      "businessValue": "I can calculate accurate cart analytics including total items and revenue",
      "acceptanceCriteria": [
        "quantity field mapped to quantity in output",
        "line_total field mapped to lineTotal in output",
        "Both fields are optional (default to undefined if missing)",
        "quantity of 0 is valid (e.g., wishlists)"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "M",
      "dependencies": [],
      "completedAt": "2025-12-08"
    },
    {
      "id": "US010",
      "title": "Call A Rest Api",
      "userStory": "As a backend developer, I want to call a REST API endpoint to normalize cart events so that I can integrate cart normalization into any service without importing the package directly, enabling language-agnostic access and centralized processing",
      "businessValue": "I can integrate cart normalization into any service without importing the package directly, enabling language-agnostic access and centralized processing",
      "acceptanceCriteria": [
        "POST /cart-events/normalize endpoint accepts RawCartEvent JSON body",
        "Returns normalized CartProduct[] array with extracted product IDs",
        "Follows existing product-service patterns (Middy middleware, Zod validation, error handling)",
        "Supports batch processing of multiple cart events in single request",
        "Returns per-event success/failure results with summary statistics",
        "OpenAPI documentation auto-generated from Zod schemas",
        "Comprehensive test suite following existing patterns"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "L",
      "dependencies": [],
      "completedAt": "2025-12-09"
    },
    {
      "id": "US011",
      "title": "Handle Store_id As Both",
      "userStory": "As a data engineer, I want to handle store_id as both string and number input types with consistent string output so that I can process events from both App (string IDs) and Toolbar (numeric IDs) sources, and always get a consistent string output that supports non-numeric store IDs like 'uk-87262'",
      "businessValue": "I can process events from both App (string IDs) and Toolbar (numeric IDs) sources, and always get a consistent string output that supports non-numeric store IDs like 'uk-87262'",
      "acceptanceCriteria": [
        "Numeric store_id input (e.g., 8333) coerced to string '8333'",
        "String store_id input (e.g., '8333') preserved as string",
        "Non-numeric string store_id (e.g., 'uk-87262') preserved as-is",
        "Output storeId is always string type (or undefined)",
        "Empty/whitespace store_id returns undefined",
        "Shared coerceStoreId utility in @rr/shared/utils"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "L",
      "dependencies": [],
      "notes": "Implemented coerceStoreId utility in @rr/shared/utils. storeId is now always output as string type.",
      "completedAt": "2025-12-09"
    },
    {
      "id": "US012",
      "title": "Have All Product Identifiers",
      "userStory": "As a data pipeline engineer, I want to have all product identifiers grouped in a nested 'ids' object so that I get a clean separation between product data (title, price, etc.) and identifier data (productIds, extractedIds), making the output schema more organized and aligned with the product-event-normalizer",
      "businessValue": "I get a clean separation between product data (title, price, etc.) and identifier data (productIds, extractedIds), making the output schema more organized and aligned with the product-event-normalizer",
      "acceptanceCriteria": [
        "Output CartProduct has 'ids' object containing productIds and extractedIds",
        "ids.productIds is always an empty array (cart events have no schema.org data)",
        "ids.extractedIds contains IDs extracted from product URLs",
        "Both arrays are readonly and frozen",
        "Output structure aligns with @rr/product-event-normalizer output"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented nested ids object structure. ids.productIds is always empty (cart events have no schema.org data), ids.extractedIds contains URL-extracted IDs. Output aligns with product-event-normalizer.",
      "completedAt": "2025-12-10"
    }
  ],
  "technicalRequirements": {
    "constraints": [],
    "integrationNeeds": [],
    "complianceRequirements": []
  },
  "acceptanceCriteria": {
    "global": [],
    "qualityStandards": []
  },
  "constraints": {
    "timeline": "",
    "resources": [],
    "nonNegotiables": []
  },
  "metadata": {
    "version": "1.0",
    "created": "2025-12-08",
    "lastUpdated": "2025-12-10",
    "approver": ""
  },
  "progress": {
    "overall": 100,
    "completed": 12,
    "total": 12,
    "blocked": 0
  }
}
