{
  "introduction": {
    "title": "Product ID Extractor Package",
    "overview": "A modular TypeScript package ecosystem that extracts product identifiers (GTINs, SKUs, ASINs, etc.) from raw merchant URLs. Split across three packages (@rr/product-id-extractor, @rr/store-registry, @rr/url-parser) for clear separation of concerns. Designed as a shared library for internal services with an HTTP API endpoint, supporting 1000+ RPS with store-specific and generic extraction patterns.",
    "lastUpdated": "2025-12-08"
  },
  "problemStatement": {
    "problem": "Internal services need to match merchant product URLs to our product catalog, but product IDs are embedded in URLs in countless formats: path segments, query parameters, encoded values, and store-specific patterns. Without a centralized, well-tested extraction library, each service would implement its own fragile parsing logic, leading to inconsistent results, duplicated effort, and maintenance nightmares. We need a single source of truth for URL-to-productId extraction that handles our merchant network.",
    "marketOpportunity": "This package enables all downstream services (catalog matching, analytics, affiliate tracking) to reliably extract product identifiers. Currently supporting 81 configured stores with patterns for major retailers. A shared package reduces development time for new services and ensures consistent behavior across the platform.",
    "targetUsers": [
      "Internal service developers importing the package for product matching workflows",
      "API consumers needing ad-hoc URL analysis via HTTP endpoint",
      "Integration engineers adding new merchant configurations",
      "QA engineers validating extraction accuracy across merchants"
    ]
  },
  "solutionOverview": {
    "description": "A modular package ecosystem: @rr/url-parser handles URL normalization and parsing, @rr/store-registry manages store configurations with O(1) lookups, and @rr/product-id-extractor performs pattern-based extraction. Store configs map internal storeIds to domains and define store-specific pathname patterns. A generic search pattern extracts IDs from common query parameters (sku, pid, productId, etc.). The packages use safe regex (ts-regex-builder) with timeout protection. The HTTP API at POST /product-identifiers/urls exposes the functionality with batch support (1-100 URLs). The architecture prioritizes: O(1) store lookups via pre-compiled Maps, immutable frozen configs, comprehensive test coverage (40+ store fixtures), and sub-millisecond extraction times.",
    "keyFeatures": [
      "Core extraction function: extractIdsFromUrlComponents() with typed input/output",
      "Store-specific pathname pattern matching with capture group extraction",
      "Generic search pattern supporting sku, pid, productId, skuid, athcpid, upc_id, variant, prdtno params",
      "Generic pathname fallback patterns for /product/, /p/, /prod/, /prd/ URL structures",
      "Safe regex via ts-regex-builder preventing ReDoS vulnerabilities",
      "Timeout protection (100ms) checking every 5 iterations, max 12 results per URL",
      "Frozen immutable output arrays preventing mutation in Lambda warm containers",
      "HTTP API at POST /product-identifiers/urls with batch support (1-100 URLs per request)",
      "Comprehensive test suite with 40+ store fixtures and regex security validation",
      "Integrates with @rr/store-registry for store config lookups (see store-registry PRD)"
    ],
    "successMetrics": [
      "95%+ extraction success rate for URLs from configured stores",
      "Sub-1ms extraction time for warm calls (excluding network)",
      "Support 1000+ RPS via Lambda API with <10ms p99 latency",
      "97%+ code coverage across all packages",
      "Zero ReDoS vulnerabilities (validated by safe-regex tooling)",
      "New store onboarding in <30 minutes with pattern testing",
      "81 stores currently configured with room for expansion"
    ]
  },
  "userStories": [
    {
      "id": "US001",
      "title": "Extract Product IDs via Package Import",
      "userStory": "As a service developer, I want to import the package and extract product IDs from a URL so that I can integrate product ID extraction into my service without implementing parsing logic myself",
      "businessValue": "I can integrate product ID extraction into my service without implementing parsing logic myself",
      "acceptanceCriteria": [
        "Package exports extractIdsFromUrlComponents(input: ExtractIdsInput) function",
        "Input accepts urlComponents from @rr/url-parser and optional storeId",
        "Function returns { productIds: readonly string[], storeId?: string }",
        "productIds array is frozen, sorted, deduplicated, max 12 items",
        "TypeScript types and Zod schemas exported for all inputs and outputs",
        "Development mode validates input/output with Zod, production skips for performance"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented in @rr/product-id-extractor/src/extractor.ts"
    },
    {
      "id": "US002",
      "title": "Extract Product IDs from URL Pathnames",
      "userStory": "As a service developer, I want to extract product IDs from URL path segments using store-specific patterns so that I can capture IDs embedded in paths like /product/ABC123 or /p/12345.html",
      "businessValue": "I can capture IDs embedded in paths like /product/ABC123 or /p/12345.html",
      "acceptanceCriteria": [
        "patternExtractor() function applies regex patterns to URL pathname",
        "Patterns use capture groups 1 and 2 for ID extraction",
        "Multiple patterns tried in priority order until match found",
        "Store-specific patterns from @rr/store-registry applied first",
        "Generic fallback patterns (/product/, /p/, /prod/, /prd/) when no store match",
        "Extracted IDs deduplicated via Set, sorted, and frozen"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented with patternExtractor() function in extractor.ts"
    },
    {
      "id": "US003",
      "title": "Extract Product IDs from Query Parameters",
      "userStory": "As a service developer, I want to extract product IDs from URL query parameters so that I can capture IDs in query strings like ?productId=123 or ?sku=ABC",
      "businessValue": "I can capture IDs in query strings like ?productId=123 or ?sku=ABC",
      "acceptanceCriteria": [
        "Generic search pattern extracts from common param names: sku, pid, id, productid, skuid, athcpid, upc_id, variant, prdtno",
        "Store-specific searchPatterns can override generic extraction",
        "ID values must be 4-24 characters, alphanumeric with dashes",
        "Query param extraction runs after pathname extraction",
        "Results merged and deduplicated with pathname results"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented with generic SEARCH_PATTERN regex in config.ts"
    },
    {
      "id": "US004",
      "title": "Apply Generic Fallback Patterns",
      "userStory": "As a service developer, I want to apply generic fallback patterns when no store-specific config exists so that I can still extract likely product IDs from unknown merchants using common URL conventions",
      "businessValue": "I can still extract likely product IDs from unknown merchants using common URL conventions",
      "acceptanceCriteria": [
        "Generic pathname patterns match /prod/, /prd/, /p/ prefixed IDs (6-24 digits)",
        "Generic patterns match numeric IDs at end of URL paths",
        "Fallback runs when store-specific extraction yields no results",
        "Generic patterns require 6+ digit IDs to avoid false positives",
        "Generic search pattern always runs for query parameter extraction"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented with PATTERNS.pathnamePatterns and PATTERNS.searchPattern in config.ts"
    },
    {
      "id": "US005",
      "title": "Timeout Protection for Regex Extraction",
      "userStory": "As a service developer, I want extraction to timeout if regex takes too long so that I am protected from ReDoS attacks and runaway patterns that could hang my service",
      "businessValue": "I am protected from ReDoS attacks and runaway patterns that could hang my service",
      "acceptanceCriteria": [
        "PATTERN_EXTRACTOR_TIMEOUT_MS = 100ms timeout for extraction operations",
        "Timeout checked every 5 iterations (optimized to reduce syscalls)",
        "PATTERN_EXTRACTOR_MAX_RESULTS = 12 limits results per URL",
        "Warning logged when timeout occurs with duration and source length",
        "Regex lastIndex reset in finally block to prevent state issues",
        "safe-regex dev dependency validates patterns for catastrophic backtracking"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented in patternExtractorInternal() with CHECK_INTERVAL = 5"
    },
    {
      "id": "US006",
      "title": "HTTP API Endpoint for URL Analysis",
      "userStory": "As an API consumer, I want to call an HTTP endpoint to extract product IDs without importing the package so that I can use the extraction service from non-Node environments or as a quick integration",
      "businessValue": "I can use the extraction service from non-Node environments or as a quick integration",
      "acceptanceCriteria": [
        "POST /product-identifiers/urls endpoint accepts array of URLs",
        "Request body: { urls: [{ url: string, storeId?: string }] }",
        "Response includes results array with productIds, storeId, count, success per URL",
        "Response includes summary: total, successful, failed counts",
        "Batch supports 1-100 URLs per request with parallel processing",
        "URL validation blocks localhost, private IPs, metadata endpoints",
        "Zod schema validation with detailed error messages",
        "Middy middleware: httpJsonBodyParser, httpErrorHandler"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented in apps/product-service/src/functions/create-url-analysis/"
    },
    {
      "id": "US007",
      "title": "Comprehensive Test Suite",
      "userStory": "As a QA engineer, I want to run comprehensive tests validating extraction accuracy per store so that I can verify that patterns correctly extract IDs from real merchant URLs",
      "businessValue": "I can verify that patterns correctly extract IDs from real merchant URLs",
      "acceptanceCriteria": [
        "40+ JSON fixture files in __fixtures__/ with real URLs and expected IDs",
        "8 test files covering extractor, error handling, paths, query params, regex security",
        "Concurrent fixture tests via describe.concurrent and test.concurrent.each",
        "Regex security tests validate: global flag, lowercase patterns, safe-regex check",
        "Performance benchmarks for pathname patterns, search pattern, all store patterns",
        "97%+ code coverage across all extraction packages",
        "Test utilities: assertProductIdsMatch(), storeFixtureTestCases"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Vitest with globals, maxConcurrency: 10, isolate: true"
    }
  ],
  "technicalRequirements": {
    "constraints": [
      "Node.js 22.x runtime on AWS Lambda (arm64)",
      "ESM-only modules (\"type\": \"module\")",
      "TypeScript strict mode with Zod validation",
      "Sub-1ms extraction time for warm Lambda calls",
      "Max 12 product IDs per URL to prevent unbounded results"
    ],
    "integrationNeeds": [
      "@rr/url-parser for URL normalization and component parsing",
      "@rr/store-registry for store configuration lookups",
      "ts-regex-builder for safe regex pattern construction",
      "Middy.js middleware for Lambda handler composition"
    ],
    "complianceRequirements": [
      "No ReDoS vulnerabilities (validated by safe-regex)",
      "URL validation blocks private IPs and metadata endpoints",
      "Frozen immutable outputs prevent mutation bugs"
    ]
  },
  "acceptanceCriteria": {
    "global": [
      "All packages pass TypeScript strict mode compilation",
      "All packages pass ESLint with zero warnings",
      "All tests pass with 97%+ coverage",
      "Lambda cold start < 100ms, warm request < 10ms"
    ],
    "qualityStandards": [
      "Conventional commits enforced via commitlint",
      "Pre-commit hooks run lint-staged",
      "CI runs tests on every PR"
    ]
  },
  "constraints": {
    "timeline": "Feature complete - maintenance mode",
    "resources": [
      "@rr/product-id-extractor package",
      "@rr/store-registry package",
      "@rr/url-parser package",
      "apps/product-service Lambda functions"
    ],
    "nonNegotiables": [
      "Timeout protection on all regex operations",
      "Frozen output arrays for Lambda warm container safety",
      "Max 12 results per URL to prevent unbounded output"
    ]
  },
  "metadata": {
    "version": "1.0",
    "created": "2025-12-08",
    "lastUpdated": "2025-12-08",
    "approver": ""
  },
  "progress": {
    "overall": 100,
    "completed": 7,
    "total": 7,
    "blocked": 0
  }
}
