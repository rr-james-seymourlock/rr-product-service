{
  "introduction": {
    "title": "Store Registry Package",
    "overview": "A high-performance TypeScript package (@rr/store-registry) that manages merchant store configurations for Rakuten's product services. Provides O(1) constant-time lookups via pre-compiled Maps, supporting store identification by domain or internal ID. Designed for Lambda cold start optimization and horizontal scaling to 4,000+ merchants with sub-millisecond lookup times.",
    "lastUpdated": "2025-12-08"
  },
  "problemStatement": {
    "problem": "Rakuten's product services need to identify merchants from URLs and apply store-specific processing rules. With 4,000+ merchants in the network, each with unique domains, aliases, URL patterns, and ID formats, we need a centralized registry that: (1) provides instant O(1) lookups regardless of store count, (2) supports multiple domains/aliases per merchant, (3) pre-compiles regex patterns to avoid runtime overhead, (4) maintains immutability for Lambda warm container safety, and (5) minimizes cold start impact. Without this, each service would implement its own store matching logic, causing inconsistencies and performance issues at scale.",
    "marketOpportunity": "The store registry is foundational infrastructure for all Rakuten product services. It enables product ID extraction, catalog matching, affiliate tracking, and merchant analytics. Current deployment supports 81 stores with architecture validated for 2,000+ stores. Performance characteristics (0.29ms cold start, <5μs lookups, ~45KB memory) ensure the registry adds negligible overhead while enabling consistent merchant identification across all services.",
    "targetUsers": [
      "Product ID extraction service requiring store-specific patterns",
      "Catalog matching services identifying merchants from URLs",
      "Analytics pipelines needing merchant metadata",
      "Integration engineers onboarding new merchants",
      "Future services requiring merchant-specific configuration"
    ]
  },
  "solutionOverview": {
    "description": "A standalone package exporting four pre-compiled ReadonlyMaps built at module load: STORE_ID_CONFIG (ID→config), STORE_DOMAIN_CONFIG (domain→config), STORE_NAME_CONFIG (domain→ID, deprecated), and COMPILED_PATTERNS (ID→RegExp[]). The getStoreConfig() function provides unified lookup by domain or ID. All configurations are deep-frozen for immutability. Store configs support: primary domain, ID aliases, domain aliases, pathname patterns, search patterns, ID transformation functions, and pattern format documentation. Cold start optimizations include pre-allocated arrays and imperative loops eliminating intermediate allocations.",
    "keyFeatures": [
      "O(1) constant-time lookups via pre-compiled Maps (~5μs per lookup)",
      "Four lookup Maps: STORE_ID_CONFIG, STORE_DOMAIN_CONFIG, STORE_NAME_CONFIG, COMPILED_PATTERNS",
      "81 stores currently configured with architecture supporting 4,000+",
      "Domain and ID alias system for multi-brand merchants (e.g., Gap Inc. with 5 aliases)",
      "Pre-compiled RegExp patterns via ts-regex-builder preventing runtime compilation",
      "Optional transformId functions for store-specific ID normalization",
      "Deep-frozen immutable configs safe for Lambda warm containers",
      "Cold start optimization: 0.29ms initialization, projected 5-8ms at 2,000 stores",
      "Memory efficient: ~45KB for 81 stores, projected ~1.1MB for 2,000 stores",
      "Structured JSON logging with namespace support"
    ],
    "successMetrics": [
      "O(1) lookup performance independent of store count",
      "Cold start initialization <10ms for 2,000+ stores",
      "Memory footprint <2MB for 4,000 stores",
      "100% test coverage for registry logic",
      "Zero runtime regex compilation (all pre-compiled)",
      "Support 1,000+ RPS with <1ms total lookup overhead",
      "New store onboarding in <15 minutes"
    ]
  },
  "userStories": [
    {
      "id": "US001",
      "title": "Look Up A Store",
      "userStory": "As a service developer, I want to look up a store configuration by domain name so that I can identify which merchant a URL belongs to and retrieve their specific settings",
      "businessValue": "I can identify which merchant a URL belongs to and retrieve their specific settings",
      "acceptanceCriteria": [
        "getStoreConfig({ domain: 'target.com' }) returns full StoreConfigInterface",
        "STORE_DOMAIN_CONFIG provides direct domain-to-config O(1) lookup",
        "Lookup returns undefined for unknown domains (no errors thrown)",
        "Domain aliases resolve to parent store configuration",
        "Lookup performance is <5μs regardless of registry size"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented via STORE_DOMAIN_CONFIG Map and getStoreConfig() function"
    },
    {
      "id": "US002",
      "title": "Look Up A Store",
      "userStory": "As a service developer, I want to look up a store configuration by internal store ID so that I can retrieve merchant settings when I already know the Rakuten store ID",
      "businessValue": "I can retrieve merchant settings when I already know the Rakuten store ID",
      "acceptanceCriteria": [
        "getStoreConfig({ id: '5246' }) returns full StoreConfigInterface",
        "STORE_ID_CONFIG provides direct ID-to-config O(1) lookup",
        "Lookup returns undefined for unknown IDs (no errors thrown)",
        "ID aliases resolve to parent store configuration",
        "ID lookup takes precedence when both domain and ID provided"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented via STORE_ID_CONFIG Map and getStoreConfig() function"
    },
    {
      "id": "US003",
      "title": "Access Pre-compiled Regex Patterns",
      "userStory": "As a service developer, I want to access pre-compiled regex patterns for a store so that I can extract product IDs without runtime regex compilation overhead",
      "businessValue": "I can extract product IDs without runtime regex compilation overhead",
      "acceptanceCriteria": [
        "COMPILED_PATTERNS Map provides ID-to-RegExp[] lookup",
        "Only stores with pathnamePatterns are included (74 of 81 stores)",
        "Patterns are ReadonlyArray<RegExp> preventing mutation",
        "All patterns have global flag enabled for proper matching",
        "Patterns built with ts-regex-builder for ReDoS safety"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Implemented via COMPILED_PATTERNS Map with 74 stores having patterns"
    },
    {
      "id": "US004",
      "title": "Add A New Store",
      "userStory": "As a integration engineer, I want to add a new store configuration with custom patterns so that I can onboard new merchants to the Rakuten network",
      "businessValue": "I can onboard new merchants to the Rakuten network",
      "acceptanceCriteria": [
        "StoreConfigInterface defines: id, domain, aliases?, patternFormats?, pathnamePatterns?, searchPatterns?, transformId?",
        "Config added to mutableStoreConfigs array in config.ts",
        "Patterns built with ts-regex-builder for safety",
        "Config automatically deep-frozen at module load",
        "New store appears in all four lookup Maps after rebuild"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "81 stores configured in config.ts with StoreConfigInterface schema"
    },
    {
      "id": "US005",
      "title": "Configure Domain And Id",
      "userStory": "As a integration engineer, I want to configure domain and ID aliases for multi-brand merchants so that I can map multiple domains and IDs to a single parent store configuration",
      "businessValue": "I can map multiple domains and IDs to a single parent store configuration",
      "acceptanceCriteria": [
        "aliases field accepts ReadonlyArray<StoreAlias> with {id, domain} pairs",
        "Alias domains appear in STORE_DOMAIN_CONFIG pointing to parent config",
        "Alias IDs appear in STORE_ID_CONFIG pointing to parent config",
        "Memory efficient: aliases share reference to parent config object",
        "Example: Gap Inc. has 5 aliases (gapfactory, oldnavy, bananarepublic, etc.)"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "Gap Inc. configured with 5 aliases demonstrating full capability"
    },
    {
      "id": "US006",
      "title": "Define An Id Transformation",
      "userStory": "As a integration engineer, I want to define an ID transformation function for stores with non-standard formats so that I can normalize extracted IDs to match our catalog format",
      "businessValue": "I can normalize extracted IDs to match our catalog format",
      "acceptanceCriteria": [
        "transformId field accepts (id: string) => string function",
        "Function called after pattern extraction, before result return",
        "Examples: remove prefixes (p- → sku-), remove characters, change separators",
        "Current stores using: love-scent.com, ikea.com, magneticme.com",
        "Function is optional - omit for stores needing no transformation"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "3 stores use transformId: love-scent.com, ikea.com, magneticme.com"
    },
    {
      "id": "US007",
      "title": "Have The Registry Initialize",
      "userStory": "As a platform engineer, I want to have the registry initialize with minimal cold start impact so that Lambda functions start quickly even with thousands of store configurations",
      "businessValue": "Lambda functions start quickly even with thousands of store configurations",
      "acceptanceCriteria": [
        "All four Maps built at module load (one-time cost)",
        "Pre-allocated arrays with exact sizes eliminate resizing",
        "Imperative loops avoid intermediate array allocations",
        "Current cold start: 0.29ms for 81 stores",
        "Projected cold start: 5-8ms for 2,000 stores",
        "Build timing logged for observability"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "L",
      "dependencies": [],
      "notes": "0.29ms cold start verified, pre-allocated arrays and imperative loops implemented"
    },
    {
      "id": "US008",
      "title": "Have All Configurations Deeply",
      "userStory": "As a platform engineer, I want to have all configurations deeply frozen for immutability so that Lambda warm containers cannot accidentally mutate shared state",
      "businessValue": "Lambda warm containers cannot accidentally mutate shared state",
      "acceptanceCriteria": [
        "All StoreConfigInterface objects are Object.freeze()'d",
        "Nested arrays (aliases, patterns, patternFormats) are frozen",
        "Nested objects (each alias) are frozen",
        "TypeScript readonly modifiers enforce at compile time",
        "Final storeConfigs export is frozen array of frozen objects"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "freezeStoreConfig() and freezeAlias() implement deep freezing"
    },
    {
      "id": "US009",
      "title": "Iterate Over All Store",
      "userStory": "As a service developer, I want to iterate over all store configurations so that I can perform bulk operations like validation or reporting across all merchants",
      "businessValue": "I can perform bulk operations like validation or reporting across all merchants",
      "acceptanceCriteria": [
        "storeConfigs export provides ReadonlyArray<StoreConfigInterface>",
        "Array contains 81 frozen store configuration objects",
        "Iteration does not affect lookup Map performance",
        "Can filter/map without mutating original array",
        "Useful for admin tooling, reports, and bulk validation"
      ],
      "status": "completed",
      "priority": "P1",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "storeConfigs exported as ReadonlyArray<StoreConfigInterface>"
    },
    {
      "id": "US010",
      "title": "Verify Registry Performance And",
      "userStory": "As a QA engineer, I want to verify registry performance and correctness so that I can ensure the registry meets performance requirements at scale",
      "businessValue": "I can ensure the registry meets performance requirements at scale",
      "acceptanceCriteria": [
        "31 tests covering all lookup mechanisms and edge cases",
        "Performance tests verify <0.01ms average lookup time",
        "1000 RPS simulation completes in <50ms",
        "100% code coverage for registry logic",
        "Tests verify O(1) performance independent of store position"
      ],
      "status": "completed",
      "priority": "P0",
      "estimatedComplexity": "M",
      "dependencies": [],
      "notes": "31 tests in registry.test.ts with 100% coverage and performance assertions"
    }
  ],
  "technicalRequirements": {
    "constraints": [
      "Node.js 22.x runtime (ESM-only)",
      "TypeScript strict mode with readonly modifiers",
      "All Maps must be ReadonlyMap at runtime",
      "O(1) lookup complexity regardless of store count",
      "Cold start <10ms for 2,000+ stores"
    ],
    "integrationNeeds": [
      "@rr/shared for logger utility",
      "ts-regex-builder for safe pattern construction",
      "Consumed by @rr/product-id-extractor for pattern access"
    ],
    "complianceRequirements": [
      "All regex patterns validated for ReDoS safety",
      "No mutable state exposed (deep freeze all exports)",
      "Structured logging for observability"
    ]
  },
  "acceptanceCriteria": {
    "global": [
      "Package compiles with TypeScript strict mode",
      "All exports are properly typed",
      "100% test coverage for registry logic",
      "Performance tests verify O(1) lookups"
    ],
    "qualityStandards": [
      "ESLint passes with zero warnings",
      "Conventional commits enforced",
      "Pre-commit hooks validate changes"
    ]
  },
  "constraints": {
    "timeline": "Feature complete - maintenance mode",
    "resources": [
      "packages/store-registry/src/registry.ts - Map builders and getStoreConfig()",
      "packages/store-registry/src/config.ts - Store configurations",
      "packages/store-registry/src/types.ts - TypeScript interfaces"
    ],
    "nonNegotiables": [
      "O(1) constant-time lookups (no linear scans)",
      "Deep immutability for Lambda warm container safety",
      "Pre-compiled patterns (no runtime regex compilation)"
    ]
  },
  "metadata": {
    "version": "1.0",
    "created": "2025-12-08",
    "lastUpdated": "2025-12-08",
    "approver": ""
  },
  "progress": {
    "overall": 100,
    "completed": 10,
    "total": 10,
    "blocked": 0
  }
}
